The rising popularity of JavaScipt  has brought with it a lot of changes. Today, the face of web development is totally different. Some things were hard to imagine to be done on the servers as well as the web browsers, several years back, or they were encapsulated within sandboxed environments like Flash or Java Applets. Now these things can be done nowadays on the web with JavaScript. 

Before digging into Node.js, let's answer some of the questions.

Have you ever heard this terminilogy before : "Node.js" ?
Are you familiar with Javascript or anything with a similar background?
 
Maybe you are, maybe you are not. Maybe you've heard about Node.js but the only idea you have is that it has something to do with "higly scalable" or "real time" apps. The common knowledge about Node.js is that it is JavaScript for the server-side. You may have wondred why would anyone want that? Some programmers know exactly what Node.js is. But, they aren't sure when or why to use it.

As Wikipedia states: “Node.js is a packaged compilation of Google’s V8 JavaScript engine, the libuv platform abstraction layer, and a core library, which is itself primarily written in JavaScript.” 

Beyond that, it’s worth noting that Ryan Dahl, the creator of Node.js, was aiming to create real-time websites with push capability, “inspired by applications like Gmail”. In Node.js, he gave developers a tool for working in the non-blocking, event-driven I/O paradigm. Quoting him : 
"After over 20 years of stateless-web based on the stateless request-response paradigm, we finally have web applications with real-time, two-way connections."

Node.js stands out in real-time web applications and employs push technology over web-sockets. What is so special about that? Well, the answer is simple. We've had over 20 years of stateless-web based on stateless request-response paradigm. Now, we finally have web applications with real-time, two-way connections, where both the client and server can communicate freely. This allows them to exchange data freely. It is all based on open web stack running over standard port 80. For years we've had this in the form of Flash and Java Applets. In reality, those were just sandboxed environments using the web as a transport protocol to be delivered to the client. They ran in isolation and often operated over non-standard ports. This required extra permissions and such

So grab some coffee or tea. Sir back in your chair and relax. This book will tell you what exactly Node.js is, what it does, where and when you can use it, how you can use it and what makes it the next big thing.

We will get started by looking at what exactly Node.js refers to. We will develop an understanding of how it is different from other web-frameworks, languages or platforms. We will also look at how JavaScript development in Node.js is different from that done in a browser.

Next up, we will discuss the origin of Node.js. What is role of Node.js in these times, and how it serves our needs in ways that other JavaScript runtime cannot.  

Next, we will stay with the good old tradition of writing a "Hello World" application, which is a most basic Node.js application that "does" something.

Then, we will discuss what kind of "real" application we want to build, dissect the different parts which need to be implemented to assemble this application, and start working on each of these parts step-by-step.

Three features make Node.js so elegant. It's easy to use, fast and scalable. It's as easy that a little code goes a long way and uses its own concurrency model. The model is a lot simpler than traditional O/S threads. Like the client-side JS libraries, Node.js provides abstraction so that a lot of boilerplate code is handled under the covers. That is a great thing, especially if you're a novice to intermediate developer. But it isn't so good if you're an expert and you want to get some low-level functionality. The scalability of Node.js results from better memory under high loads and non-blocking execution model. Functions in Node.js never perform I/O directly and hence, the process never blocks. This leaves the developer free from being concerned about dead-locking processes and he's able to focus on the code at hand. These are some of the perks of using Node.js by beginner to intermediate programmers to develop fast systems.

Once you finish this book, it's our promise that you would be able to create complete web applications that would allow users of this application to view the web pages and upload their files. Isn't that just great? Well, that's just the beginning. For some, well, this may not exactly be a big deal or awe-inspiring. But wait, we'll go some extra miles and create the code. This code will not just be able to make such things possible, but it'll create a simple and yet, complete framework which will separate the different aspects of the application in a clean manner. Feeling confused? Hang on for a while. As you read on, you will understand what I exactly mean and what we're trying to achieve. 
